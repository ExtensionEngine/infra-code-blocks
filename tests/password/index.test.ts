import * as assert from 'node:assert';
import { InlineProgramArgs } from '@pulumi/pulumi/automation';
import { SecretsManagerClient } from '@aws-sdk/client-secrets-manager';
import {
  DescribeSecretCommand,
  GetSecretValueCommand,
} from '@aws-sdk/client-secrets-manager';
import { PasswordTestContext } from './test-context';
import { after, before, describe, it } from 'node:test';
import * as automation from '../automation';

const programArgs: InlineProgramArgs = {
  stackName: 'dev',
  projectName: 'icb-test-password',
  program: () => import('./infrastructure'),
};

describe('Password component deployment', () => {
  const region = process.env.AWS_REGION;
  if (!region) {
    throw new Error('AWS_REGION environment variable is required');
  }

  const ctx: PasswordTestContext = {
    outputs: {},
    config: {
      autoGeneratedPasswordName: 'password-test-auto',
    },
    clients: {
      secretsManager: new SecretsManagerClient({ region }),
    },
  };

  before(async () => {
    ctx.outputs = await automation.deploy(programArgs);
  });

  after(() => automation.destroy(programArgs));

  it('should create a password component with the correct configuration', async () => {
    const password = ctx.outputs.autoGeneratedPassword.value;

    assert.ok(
      password.secret,
      'Password component should have secret property',
    );
    assert.ok(password.value, 'Password component should have value property');
    assert.strictEqual(
      password.name,
      ctx.config.autoGeneratedPasswordName,
      'Password name should match input',
    );
  });

  it('should create a secret with auto generated password', async () => {
    const password = ctx.outputs.autoGeneratedPassword.value;

    const secretResult = await ctx.clients.secretsManager.send(
      new DescribeSecretCommand({
        SecretId: password.secret.arn,
      }),
    );

    assert.ok(secretResult.ARN, 'Secret should exist');
    assert.ok(secretResult.Name, 'Secret should have a name');
    assert.ok(secretResult.CreatedDate, 'Secret should have creation date');

    const expectedPrefix = `${programArgs.stackName}/${programArgs.projectName}/${ctx.config.autoGeneratedPasswordName}-`;
    assert.ok(
      secretResult.Name?.startsWith(expectedPrefix),
      `Secret name should start with ${expectedPrefix}`,
    );
  });

  it('should generate a random password with correct format', async () => {
    const password = ctx.outputs.autoGeneratedPassword.value;

    const secretValue = await ctx.clients.secretsManager.send(
      new GetSecretValueCommand({
        SecretId: password.secret.arn,
      }),
    );

    const passwordValue = secretValue.SecretString;
    assert.ok(passwordValue, 'Password value should exist');
    assert.strictEqual(
      passwordValue.length,
      16,
      'Password should be 16 characters long',
    );
    assert.ok(secretValue.VersionId, 'Secret should have a version ID');
  });

  it('should create a secret with custom password value', async () => {
    const password = ctx.outputs.customPassword.value;

    const secretValue = await ctx.clients.secretsManager.send(
      new GetSecretValueCommand({
        SecretId: password.secret.arn,
      }),
    );

    const passwordValue = secretValue.SecretString;
    assert.strictEqual(
      passwordValue,
      'customPass!',
      'Password should match custom value',
    );
  });

  it('should have password value as a secret', async () => {
    console.log('outputs1', await automation.getOutputs(programArgs));
    const autoGeneratePasswordValue = ctx.outputs.autoGeneratePasswordValue;
    assert.ok(
      autoGeneratePasswordValue.secret,
      'Auto-generated password should be a secret',
    );

    const customPasswordValue = ctx.outputs.customPasswordValue;
    assert.ok(customPasswordValue.secret, 'Custom password should be a secret');
  });
});
